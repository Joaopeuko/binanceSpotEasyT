"{'binanceSpotEasyT': {'type': 'directory', 'initialization.py': {'type': 'python file', 'Initialize': {'introduction': 'This class ensure that the platform are working properly.\\nIf it is connected on the internet, and if the symbol that you are trying to use exists or was not mistyped.', '__init__': {'introduction': 'Initialize the constructor and set the _log.'}, '_initialize_account': {'introduction': 'This function check if it is possible to login into Binance using the API KEY and SECRET.\\nYou must have this information.\\n\\n', 'raises': '\\n    raise_for_status():\\n        This error happens when it returns an error.\\n\\n', 'returns': '\\n    It returns True if it works fine.'}, 'initialize_platform': {'introduction': 'This function is responsible to initialize the platform that will be used to trade.\\n\\n', 'raises': '\\n    PlatformNotInitialized:\\n        Raise this error when there are some problem with internet connection.\\n\\n', 'returns': '\\n    It returns true if initialized else return false.\\n\\n', 'examples': '\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> initialize = Initialize()\\n    >>> # The function and the function return:\\n    >>> initialize.initialize_platform()\\n    True'}, 'initialize_symbol': {'introduction': 'This function is responsible to initialize as many symbols as you want.\\n\\n', 'args': {}, 'raises': '\\n    SymbolNotFound: If not possible to initialize the symbol raises this error.\\n\\n', 'returns': '\\n    When the symbol is successfully initialized it returns True and, it updates the list\\n    self.symbol_initialized if you want to work with the symbols correctly initialized.\\n\\n', 'examples': \"\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> # The function and the function return:\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    True\\n    >>> # Check initialize.symbol_initialized to see the list of initialized symbols\\n    >>> initialize.symbol_initialized\\n    ['BTCUSDT']\"}}, 'PlatformNotInitialized': {'introduction': 'Raise this error when ping was not able to be retrieved.'}, 'SymbolNotFound': {'introduction': 'Raise this error when the symbol is not found.'}, 'get_account': {'introduction': \"This functions returns User's account information.\\n\", 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'key': {'description': '\\n        It is the key used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'secret': {'description': '\\n        It is the secret used to authenticate transaction for Binance\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The return is a JSON object that contains account information'}, 'setup_environment': {'introduction': 'This function are responsible to check if the credentials are available, it is used to prevent future problems.\\n\\n', 'args': {}, 'raises': '\\n    CredentialsNotFound:\\n        This error returns when the key is missing, empty or invalid.\\n\\n', 'returns': ''}, 'urlencode': {'introduction': 'Encode a dict or sequence of two-element tuples into a URL query string.\\n\\nIf any values in the query arg are sequences and doseq is true, each\\nsequence element is converted to a separate parameter.\\n\\nIf the query arg is a sequence of two-element tuples, the order of the\\nparameters in the output will match the order of parameters in the\\ninput.\\n\\nThe components of a query arg may each be either a string or a bytes type.\\n\\nThe safe, encoding, and errors parameters are passed down to the function\\nspecified by quote_via (encoding and errors only if a component is a str).'}}, 'trade.py': {'type': 'python file', 'Trade': {'introduction': 'This class is responsible to handle all the trade requests.', '__init__': {'introduction': 'It is allowed to have only one position at time per symbol, right now it is not possible to open a position and\\nincrease the size of it or to open opposite position. Open an open position will close the other direction one.\\n\\n', 'args': {'symbol': {'description': '\\n        It is the symbol you want to open or close or check if already have an operation opened.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'lot': {'description': '\\n        It is how many shares you want to trade, many symbols allow fractions and others requires a\\n        certain amount. It can be 0.01, 100.0, 1000.0, 10000.0.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'stop_loss': {'description': '\\n        It is how much you accept to lose. Example: If you buy a share for US$10.00, and you accept to lose US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$9.00 (sometimes more, somtime less,\\n        the US$9.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'take_profit': {'description': '\\n        It is how much you accept to win. Example: If you buy a share for US$10.00, and you accept to win US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$11.00 (sometimes more, somtime less,\\n        the US$11.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.', 'type': <class 'float'>, 'default': 'No default argument'}}}, 'normalize': {'introduction': 'This function normalize the price to ensure a precision that is required by the platform\\n\\n', 'args': {'price': {'description': '\\n        It is the price that you want to be normalized, usually is the last price to open a market position.\\n\\n', 'type': <class 'float'>, 'default': 'No default argument'}}, 'returns': '\\n    It returns the float price normalized under a precision that is accepted by the platform.\\n\\n', 'examples': \"\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=1.0, stop_loss=1.0, take_profit=1.0)\\n    >>> # The normalize function is used inside other functions, but the idea is to normalize the value to\\n    >>> # be accepted in the trade request. If you want to see this function in action you can look at\\n    >>> # open_buy() and open_sell()\\n    >>> btcusdt_trade.normalize(12.3456789101112131415)\\n    12.3456789\"}, 'open_buy': {'introduction': 'This functions when called send a buy request to Binance with the parameters in the attributes.\\n\\n', 'returns': '\\n    It returns None, but if an error occurs when open a position it will break.\\n\\n', 'examples': \"\\n\\n    Try this on your demo account with fake money, a position will be opened.\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> # Notice that the stop and profit are zero, that is because the Spot do not use it.\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=0.01, stop_loss=0.0, take_profit=0.0)\\n    >>> # When it works it returns None\\n    >>> btcusdt_trade.open_buy()\\n    None\\n    >>> # Just for curiosity, if you want to try to open a buy position with this sell opened you will close\\n    >>> # the sell position\\n    >>> btcusdt_trade.open_sell()\\n    None\"}, 'open_sell': {'introduction': 'This functions when called send a sell request to Binance with the parameters in the attributes.\\n\\n', 'returns': '\\n    It returns None, but if an error occurs when open a position it will break.\\n\\n', 'examples': \"\\n\\n    Try this on your demo account with fake money, a position will be opened.\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> # Notice that the stop and profit are zero, that is because the Spot do not use it.\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=0.01, stop_loss=0.0, take_profit=0.0)\\n    >>> # When it works it returns None\\n    >>> btcusdt_trade.open_sell()\\n    None\\n    >>> # Just for curiosity, if you want to try to open a buy position with this sell opened you will close\\n    >>> # the sell position\\n    >>> btcusdt_trade.open_buy()\\n    None\"}, 'position_check': {'introduction': \"This function checks if there are a position opened and update the variable self.trade_direction.\\nIf there is no position, the self.trade_direction will be updated to None, else, it updates with the trade\\ndirection, which can be 'sell' or 'buy'.\\n\\n\", 'returns': '\\n    This function update the variable self.trade_direction and do not return a result.\\n\\n', 'examples': \"\\n\\n    Try this on your demo account with fake money, a position will be opened.\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=0.01, stop_loss=0.0, take_profit=0.0)\\n    >>> btcusdt_trade._trade_allowed = True\\n    >>> # Position check it is just to ensure that the btcusdt_trade.trade_direction are in the right direction.\\n    >>> # The btcusdt_trade.trade_direction is automatically handled by buy open_sell() and open_buy() and\\n    >>> # it returns the trade direction or None when there is no trade opened.\\n    >>> btcusdt_trade.trade_direction\\n    None\\n    >>> btcusdt_trade.position_open(True, False)\\n    'buy'\\n    >>> btcusdt_trade.trade_direction\\n    'buy'\\n    >>> # After I open a buy position, it returns 'buy' to trade_direction, but, what happens if I manually\\n    >>> # change the direction?\\n    >>> btcusdt_trade.trade_direction = 'coffee shop'\\n    >>> btcusdt_trade.trade_direction\\n    'coffee shop'\\n    >>> # It is possible to see that the trade_direction was changed.\\n    >>> # and the position_check() is called in all the functions that opens and closes position\\n    >>> # to ensure that direction is correct, I will call position_check() to fix my change to 'coffee shop'\\n    >>> btcusdt_trade.position_check()\\n    None\\n    >>> btcusdt_trade.trade_direction\\n    'buy'\\n    >>> # It worked.\\n    >>> # That is it, I will just the position that I opened before.\\n    >>> btcusdt_trade.position_close()\"}, 'position_close': {'introduction': 'This functions checks the trade direction, and it opens an opposite position to the current one to close it.\\nIf there is no position nothing happens.\\n\\n', 'returns': '\\n    Close the current position by opening an opposite one.\\n\\n', 'examples': \"\\n\\n    Try this on your demo account with fake money, a position will be opened.\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=0.01, stop_loss=0.0, take_profit=0.0)\\n    >>> btcusdt_trade._trade_allowed = True\\n    >>> # To know more about btcusdt_trade._trade_allowed look the Examples in position_open() documentation.\\n    >>> btcusdt_trade.position_open(True, Sell)\\n    'buy'\\n    >>> # When there is a position opened, btcusdt_trade.position_close() will open a position in a different\\n    >>> # direction to close it.\\n    >>> btcusdt_trade.position_close()\\n    None\\n    # It checks the trading direction, return none when there is no trade opened.\\n    >>> btcusdt_trade.trade_direction\\n    None\\n    # I will open a buy position, check the trade direction and close it!\\n    >>> btcusdt_trade.position_open(True, False)\\n    'buy'\\n    >>>  btcusdt_trade.trade_direction\\n    'buy'\\n    >>> btcusdt_trade.position_close()\\n    >>> # We can see that it worked!\\n    >>> # What happens when I call btcusdt_trade.position_close() with no position opened?\\n    >>> btcusdt_trade.position_close()\\n    None\\n    >>> # Nothing happens, there are no position to be closed.\"}, 'position_open': {'introduction': 'This function receives two bool variables, buy and sell, if one of this variable is true and the other is false,\\nit opens a position to the side that is true, if both variable is true or both variable is false, it does not\\nopen a position.\\n\\n', 'args': {'buy': {'description': '\\n        When buy is TRUE it receives a positive signal to open a position. When false, it is ignored.\\n\\n    ', 'type': <class 'bool'>, 'default': 'No default argument'}, 'sell': {'description': '\\n        When sell is TRUE it receives a positive signal to open a position. When false, it is ignored.\\n\\n', 'type': <class 'bool'>, 'default': 'No default argument'}}, 'returns': '\\n    It opens the position.\\n\\n', 'examples': \"\\n\\n    Try this on your demo account with fake money, a position will be opened.\\n\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.trade import Trade\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    True\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    True\\n    >>> # Notice that the stop and profit are zero, that is because the Spot do not use it.\\n    >>> btcusdt_trade = Trade(symbol='BTCUSDT', lot=0.01, stop_loss=0.0, take_profit=0.0)\\n    >>> # _trade_allowed is False by default, this attribute will be handled in another project,\\n    >>> # that is why it exists. Let assign to True and see what happens:\\n    >>> btcusdt_trade._trade_allowed = True\\n    >>> btcusdt_trade._trade_allowed\\n    True\\n    >>> # Currently, I do not have a position for BTC, so first I will try to open a SELL position to see\\n    >>> # what happens since it is not allowed.\\n    >>> btcusdt_trade.position_open(False, True)\\n    2022-03-29 10:36:38,580 WARNING - warning - A SELL position are not allowed in Binance Spot, you can only sell a symbol if you have it.\\n    2022-03-29 10:36:38,580 WARNING - warning - A SELL position are not allowed in Binance Spot, you can only sell a symbol if you have it.\\n    # Now that you know what happens lets try to BUY a position.\\n    >>> btcusdt_trade.position_open(True, False)\\n    'buy'\\n    >>> # It worked as a expected, let close it. You can check, the position will be closed.\\n    >>> btcusdt_trade.position_close()\\n    None\\n    >>> # To finish, let see what happens if both arguments are True\\n    >>> btcusdt_trade.position_open(True, True)\\n    None\\n    >>> # Nothing happens, but when both are False?\\n    >>> btcusdt_trade.position_open(False, False)\\n    None\\n    >>> # Nothing happens\"}}, 'get_price_last': {'introduction': 'This function is used to get the last price of a determined symbol, the last price is the most recent one.\\n', 'args': {'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want the most recent price.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It returns the price in a string format'}, 'get_symbol_asset_balance': {'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'key': {'description': '\\n        It is the key used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'secret': {'description': '\\n        It is the secret used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want to know how much of that currency you have.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    A float number with the amount of a specific currency asked for'}, 'setup_environment': {'introduction': 'This function are responsible to check if the credentials are available, it is used to prevent future problems.\\n\\n', 'args': {}, 'raises': '\\n    CredentialsNotFound:\\n        This error returns when the key is missing, empty or invalid.\\n\\n', 'returns': ''}, 'urlencode': {'introduction': 'Encode a dict or sequence of two-element tuples into a URL query string.\\n\\nIf any values in the query arg are sequences and doseq is true, each\\nsequence element is converted to a separate parameter.\\n\\nIf the query arg is a sequence of two-element tuples, the order of the\\nparameters in the output will match the order of parameters in the\\ninput.\\n\\nThe components of a query arg may each be either a string or a bytes type.\\n\\nThe safe, encoding, and errors parameters are passed down to the function\\nspecified by quote_via (encoding and errors only if a component is a str).'}}, 'timeframe.py': {'type': 'python file', 'TimeFrame': {'introduction': 'There are incompatibilities and different patterns in writing the timeframe between platforms.\\nThis class attend to reduce the chance of errors providing the same timeframe structure between platforms.\\n\\n', 'examples': '\\n    You can find an example of the TimeFrame usage in update_rates() function in Rates documentation', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}}, 'util.py': {'type': 'python file', 'CredentialsNotFound': {'introduction': 'Raise this error when the key or the BINANCE_API_SECRET are not found, it does not prevent if the key or the BINANCE_API_SECRET are wrong.'}, 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'get_account': {'introduction': \"This functions returns User's account information.\\n\", 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'key': {'description': '\\n        It is the key used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'secret': {'description': '\\n        It is the secret used to authenticate transaction for Binance\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The return is a JSON object that contains account information'}, 'get_price_last': {'introduction': 'This function is used to get the last price of a determined symbol, the last price is the most recent one.\\n', 'args': {'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want the most recent price.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It returns the price in a string format'}, 'get_symbol_asset_balance': {'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'url_base': {'description': '\\n        url_base is the parameter containing the principal URL to call the endpoint.\\n        There are many kind of url_base, usually one for test and the other for real transaction.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'key': {'description': '\\n        It is the key used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'secret': {'description': '\\n        It is the secret used to authenticate transaction for Binance\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want to know how much of that currency you have.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    A float number with the amount of a specific currency asked for'}, 'load_dotenv': {'introduction': 'Parse a .env file and then load all the variables found as environment variables.\\n\\n- *dotenv_path*: absolute or relative path to .env file.\\n- *stream*: Text stream (such as `io.StringIO`) with .env content, used if\\n  `dotenv_path` is `None`.\\n- *verbose*: whether to output a warning the .env file is missing. Defaults to\\n  `False`.\\n- *override*: whether to override the system environment variables with the variables\\n  in `.env` file.  Defaults to `False`.\\n- *encoding*: encoding to be used to read the file.\\n\\nIf both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file.'}, 'setup_environment': {'introduction': 'This function are responsible to check if the credentials are available, it is used to prevent future problems.\\n\\n', 'args': {}, 'raises': '\\n    CredentialsNotFound:\\n        This error returns when the key is missing, empty or invalid.\\n\\n', 'returns': ''}, 'urlencode': {'introduction': 'Encode a dict or sequence of two-element tuples into a URL query string.\\n\\nIf any values in the query arg are sequences and doseq is true, each\\nsequence element is converted to a separate parameter.\\n\\nIf the query arg is a sequence of two-element tuples, the order of the\\nparameters in the output will match the order of parameters in the\\ninput.\\n\\nThe components of a query arg may each be either a string or a bytes type.\\n\\nThe safe, encoding, and errors parameters are passed down to the function\\nspecified by quote_via (encoding and errors only if a component is a str).'}}, 'rates.py': {'type': 'python file', 'Rates': {'introduction': 'Helper class that provides a standard way to create an ABC using\\ninheritance.', '__init__': {'args': {'symbol': {'description': '\\n    The symbol you want to retrieve previous data.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}, 'timeframe': {'description': '\\n    The timeframe you want information, like 1 minute, 5 minute, 1 week. You can find all the timeframe\\n    available in the TimeFrame Class (binanceSpotEasyT.timeframe).\\n\\ncount:\\n    It is the amount of information in the past you want. If your time frame is 5 minutes and your count is 4,\\n    it will return 4 values containing time, open, high, low, close, tick_volume information of this past 4\\n    candlesticks.', 'type': <class 'binanceSpotEasyT.timeframe.TimeFrame'>, 'default': 'No default argument'}}}, 'change_count': {'introduction': 'This function changes the count.\\n\\n', 'args': {'new_count': {'description': '\\n        It receives the new new_count\\n\\n', 'type': <class 'int'>, 'default': 'No default argument'}}, 'returns': '\\n    It updates the self._count to the new count.\\n\\n', 'examples': \"\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.timeframe import TimeFrame\\n    >>> from binanceSpotEasyT.rates import Rates\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> timeframe = TimeFrame()\\n    >>> # it will get the last 20 one minute candlestick information.\\n    >>> btcusdt_rates = Rates(symbol='BTCUSDT', timeframe=timeframe.ONE_MINUTE, count=20)\\n    >>> btcusdt_rates.update_rates()\\n    >>> len(btcusdt_rates.close)\\n    20\\n    >>> # When you change the count, you need to update the information, and you can see that it worked.\\n    >>> btcusdt_rates.change_count(5)\\n    >>> btcusdt_rates.update_rates()\\n    >>> len(btcusdt_rates.close)\\n    5\\n\\n    You can ask for this information: time, open, high, low, close, tick_volume.\"}, 'change_symbol': {'introduction': 'This function changes the symbol.\\n\\n', 'args': {'new_symbol': {'description': '\\n        It receives the new symbol\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It updates the self._symbol to the new symbol.'}, 'change_timeframe': {'introduction': 'This function changes the timeframe.\\n\\n', 'args': {'new_timeframe': {'description': '\\n        It receives the new timeframe\\n\\n', 'type': <class 'binanceSpotEasyT.timeframe.TimeFrame'>, 'default': 'No default argument'}}, 'returns': '\\n    It updates the self._timeframe to the new timeframe.'}, 'update_rates': {'introduction': 'Everytime this function is called it update the last values, it is important to have an updated\\ninformation to calculate indicators and ensure your trading strategy is working properly.\\n\\n', 'returns': '\\n    It updates the attributes in the constructor.\\n\\n', 'examples': \"\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.timeframe import TimeFrame\\n    >>> from binanceSpotEasyT.rates import Rates\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    >>> timeframe = TimeFrame()\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> # it will get the last 20 one minute candlestick information, but it will return none at the first time.\\n    >>> # the rates need the information to be updated everytime.\\n    >>> btcusdt_rates = Rates(symbol='BTCUSDT', timeframe=timeframe.ONE_MINUTE, count=20)\\n    >>> # The first time, if you try to get a rates information of the close price you will receive None\\n    >>> btcusdt_rates.close\\n    None\\n    >>> # But when you update the rates, the prices will be updated.\\n    >>> btcusdt_rates.update_rates()\\n    >>> # And the rates will be returned for the information you want.\\n    >>> btcusdt_rates.close\\n    array([47526.5 , 47501.77, 47507.21, 47481.75, 47476.75, 47494.48,\\n           47497.64, 47486.77, 47484.85, 47499.99, 47498.11, 47487.96,\\n           47473.43, 47459.  , 47466.4 , 47459.01, 47481.22, 47489.09,\\n           47510.48, 47520.  ])\\n\\n    You can ask for this information: time, open, high, low, close, tick_volume.\"}}, 'TimeFrame': {'introduction': 'There are incompatibilities and different patterns in writing the timeframe between platforms.\\nThis class attend to reduce the chance of errors providing the same timeframe structure between platforms.\\n\\n', 'examples': '\\n    You can find an example of the TimeFrame usage in update_rates() function in Rates documentation', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'setup_environment': {'introduction': 'This function are responsible to check if the credentials are available, it is used to prevent future problems.\\n\\n', 'args': {}, 'raises': '\\n    CredentialsNotFound:\\n        This error returns when the key is missing, empty or invalid.\\n\\n', 'returns': ''}}, 'tick.py': {'type': 'python file', 'Tick': {'introduction': 'Tick class is the responsible to retrieve every tick information.', '__init__': {'args': {'symbol': {'description': '\\n    It is the symbol you want information about. You can have information about time, bid, ask, last, volume.', 'type': <class 'str'>, 'default': 'No default argument'}}}, 'change_symbol': {'introduction': 'This function changes the symbol.\\n\\n', 'args': {'new_symbol': {'description': '\\n        It receives the new symbol\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It updates the self._symbol to the new symbol.'}, 'get_new_tick': {'introduction': 'Everytime this function is called it update the last tick information, it is important to have update\\ninformation know the most recent information.\\n\\n', 'returns': '\\n     It updates the attributes in the constructor.\\n\\n', 'examples': \"\\n    >>> # All the code you need to execute the function:\\n    >>> from binanceSpotEasyT.initialization import Initialize\\n    >>> from binanceSpotEasyT.tick import Tick\\n    >>> initialize = Initialize()\\n    >>> initialize.initialize_platform()\\n    >>> initialize.initialize_symbol('BTCUSDT')\\n    >>> # It will return the most recent information, but it will return None at the first time.\\n    >>> # The tick need the information to be updated everytime.\\n    >>> btcusdt_tick = Tick(symbol='BTCUSDT')\\n    >>> btcusdt_tick.ask\\n    None\\n    >>> # When you update the tick:\\n    >>> btcusdt_tick.get_new_tick()\\n    >>> btcusdt_tick.ask\\n    1.09975\\n    >>> btcusdt_tick.bid\\n    1.09975\\n    >>> # You must have notice that I used bid and ask, some exchanges do not return the last value\\n    >>> # You can find only the information for bid and ask. If you try to return last it will print 0.0.\\n    >>> # But remember, not all the exchanges do that, you must check it. Binance return the last value.\\n    >>> btcusdt_tick.last\\n    47572.46\\n\\n    You can ask for this information: time, bid, ask, last, volume.\"}}, 'setup_environment': {'introduction': 'This function are responsible to check if the credentials are available, it is used to prevent future problems.\\n\\n', 'args': {}, 'raises': '\\n    CredentialsNotFound:\\n        This error returns when the key is missing, empty or invalid.\\n\\n', 'returns': ''}}, 'shelve': 'finance', 'sub-project': 'easyT'}}"
